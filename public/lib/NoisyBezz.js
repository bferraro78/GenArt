/**
 * In perlin noise function:
 * noiseLevel = how much to multiple the 0-1 value generated by noise.
 *      the higher the level, the bigger the jump in random numbers
 * 
 * noiseScale = how "fast" your perlinNoise will move through its loaded set
 *      of perlinNoise values. New values generated each time program loads since
 *      pj5 will re-seed the perlin noise space
 * 
 *      video: https://youtu.be/YcdldZ1E9gU?si=uK29D7xMriqAuggd&t=563
 * 
 *  noise(nx, nt) - One dimension 
 */



let delta = 0.001;
// rounding error in JS, needs this number of 0s to correct to ensure
// start and end are the same
let tMax = 1.00001;

/**
 * Description
 * @param {Vector} v0
 * @param {Vector} v1
 * @param {Vector} v2
 * @param {float} noiseLevel
 * @param {float} noiseScale
 * @returns {any}
 */
function noisyQuadraticBezzX(v0, v1, v2, noiseLevel, noiseScale) {
    for (let t = 0; t <= tMax; t += delta) {
        let quad = quadratic(v0, v1, v2, t);

        let nx = noiseScale * quad.x;
        let nt = noiseScale * frameCount;

        let xNoise = noise(nx, nt);
        let noisyx = xNoise * noiseLevel + quad.x;

        vertex(noisyx, quad.y);
    }

    // TODO: Could return start and end to ensure we close shaped properly
    return [];
}

/**
 * Description
 * @param {Vector} v0
 * @param {Vector} v1
 * @param {Vector} v2
 * @param {float} noiseLevel
 * @param {float} noiseScale
 * @returns {any}
 */
function noisyQuadraticBezzY(v0, v1, v2, noiseLevel, noiseScale) {
    for (let t = 0; t <= tMax; t += delta) {
        let quad = quadratic(v0, v1, v2, t);

        let ny = noiseScale * quad.y;
        let nt = noiseScale * frameCount;

        let yNoise = noise(ny, nt);
        let noisyY = yNoise * noiseLevel + quad.y;

        vertex(quad.x, noisyY);
    }

    // TODO: Could return start and end to ensure we close shaped properly
    return [];
}

/**
 * Description
 * @param {Vector} v0
 * @param {Vector} v1
 * @param {Vector} v2
 * @param {float} noiseLevel
 * @param {float} noiseScale
 * @returns {any}
 */
function noisyQuadraticBezzXY(v0, v1, v2, noiseLevel, noiseScale) {
    for (let t = 0; t <= tMax; t += delta) {
        let quad = quadratic(v0, v1, v2, t);

        let ny = noiseScale * quad.y;
        let nx = noiseScale * quad.x;

        let nt = noiseScale * frameCount;
        let yNoise = noise(ny, nt);
        let noisyY = yNoise * noiseLevel + quad.y;

        let xNoise = noise(nx, nt);
        let noisyx = xNoise * noiseLevel + quad.x;

        vertex(noisyx, noisyY);
    }

    // TODO: Could return start and end to ensure we close shaped properly
    return [];
}

/**
 * Description
 * @param {Vector} v0
 * @param {Vector} v1
 * @param {Vector} v2
 * @param {Vector} v3
 * @returns {any}
 */
function CubicBezz(v0, v1, v2, v3) {
    for (let t = 0; t <= tMax; t += delta) {
        let quad = quadratic(v0, v1, v2, t);
        let quad1 = quadratic(v1, v2, v3, t);

        let x = lerp(quad.x, quad1.x, t);
        let y = lerp(quad.y, quad1.y, t);

        vertex(x, y);
    }
}

/**
 * Description
 * @param {Vector} v0
 * @param {Vector} v1
 * @param {Vector} v2
 * @param {Vector} v3
 * @param {float} noiseLevel
 * @param {float} noiseScale
 * @returns {any}
 */
function noisyCubicBezzX(v0, v1, v2, v3, noiseLevel, noiseScale) {
    for (let t = 0; t <= tMax; t += delta) {
        let quad = quadratic(v0, v1, v2, t);
        let quad1 = quadratic(v1, v2, v3, t);

        let x = lerp(quad.x, quad1.x, t);
        let y = lerp(quad.y, quad1.y, t);

        let nt = noiseScale * frameCount;

        let nx = noiseScale * x;
        let xNoise = noise(nx, nt);
        let noisyX = xNoise * noiseLevel + x;

        vertex(noisyX, y);
    }
}

/**
 * Description
 * @param {Vector} v0
 * @param {Vector} v1
 * @param {Vector} v2
 * @param {Vector} v3
 * @param {float} noiseLevel
 * @param {float} noiseScale
 * @returns {any}
 */
function noisyCubicBezzY(v0, v1, v2, v3, noiseLevel, noiseScale) {
    for (let t = 0; t <= tMax; t += delta) {
        let quad = quadratic(v0, v1, v2, t);
        let quad1 = quadratic(v1, v2, v3, t);

        let x = lerp(quad.x, quad1.x, t);
        let y = lerp(quad.y, quad1.y, t);

        let ny = noiseScale * y;
        let nt = noiseScale * frameCount;
        let yNoise = noise(ny, nt);
        let noisyY = yNoise * noiseLevel + y;

        vertex(x, noisyY);
    }
}

/**
 * Description
 * @param {Vector} v0
 * @param {Vector} v1
 * @param {Vector} v2
 * @param {Vector} v3
 * @param {float} noiseLevel
 * @param {float} noiseScale
 * @returns {any}
 */
function noisyCubicBezzXY(v0, v1, v2, v3, noiseLevel, noiseScale) {
    for (let t = 0; t <= tMax; t += delta) {
        let quad = quadratic(v0, v1, v2, t);
        let quad1 = quadratic(v1, v2, v3, t);

        let x = lerp(quad.x, quad1.x, t);
        let y = lerp(quad.y, quad1.y, t);

        let ny = noiseScale * y;
        let nt = noiseScale * frameCount;
        let yNoise = noise(ny, nt);
        let noisyY = yNoise * noiseLevel + y;

        let nx = noiseScale * x;
        let xNoise = noise(nx, nt);
        let noisyX = xNoise * noiseLevel + x;

        vertex(noisyX, noisyY);
    }
}

function quadratic(v0, v1, v2, t) {
    let x1 = lerp(v0.x, v1.x, t);
    let y1 = lerp(v0.y, v1.y, t);
    let x2 = lerp(v1.x, v2.x, t);
    let y2 = lerp(v1.y, v2.y, t);
    let x = lerp(x1, x2, t);
    let y = lerp(y1, y2, t);

    return createVector(x, y);
}